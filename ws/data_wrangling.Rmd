---
title: "Data wrangling"
author: "Murray Logan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: show
    collapse: no
    df_print: paged
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: textmate
    theme: spacelab
    toc: yes
    toc_float: yes
    css: ../resources/style.css
  pdf_document:
    df_print: default
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: tango
    latex_engine: xelatex
    number_sections: yes
    toc_depth: 2
  word_document:
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: tango
    toc: yes
    toc_depth: 2
output_dir: "docs"
documentclass: article
fontsize: 12pt
mainfont: Arial
mathfont: LiberationMono
monofont: DejaVu Sans Mono
classoption: a4paper
bibliography: ../resources/references.bib
---

```{r setup, include=FALSE, warnings=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
 
# Preparations

Load the necessary libraries

```{r libraries, results='markdown', eval=TRUE, message=FALSE, warning=FALSE}
library(tidyverse) #for data wrangling
```

Link to the data transformation cheatsheet 

https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf

Important data manipulation functions:

+--------------------------+-----------------------------------+------------+
|Task                      |Function                           |Package     |
+==========================+===================================+============+
|Sorting                   |`arrange()`                        |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|Adding columns            |`mutate()`                         |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|Transformations           |`mutate()`                         |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|Re-ordering factor levels |`factor(,levels=)`                 |base        |
+--------------------------+-----------------------------------+------------+
|Re-labelling              |`factor(,lab=)`                    |base        |
+--------------------------+-----------------------------------+------------+
|                          |`recode()`                         |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|Re-naming columns         |`rename(,replace=)`                |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|Filtering/Subsetting      |indexing                           |base        |
+--------------------------+-----------------------------------+------------+
|~ columns                 |`select(,...)`                     |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|                          |`pull(,...)`                       |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|~ rows                    |`filter(,...)`                     |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|Unique combinations       |`distinct()`                       |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|Reshaping data            | `pivot_longer()`, `pivot_wider()` | **tidyr**  |
+--------------------------+-----------------------------------+------------+
|Split/combine columns     | `separate()`, `unite()`           | **tidyr**  |
+--------------------------+-----------------------------------+------------+
|Aggregating               |`group_by()` `summarise()`         |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|                          |`group_by()` `count()`             |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|Merging/joining           |`*_join()`                         |**dplyr**   |
+--------------------------+-----------------------------------+------------+
|Extracting data structure |`expand()`                         |**tidyr**   |
+--------------------------+-----------------------------------+------------+
|                          |`crossing()`                       |**tidyr**   |
+--------------------------+-----------------------------------+------------+


# Data files

`load()` loads objects in R format. Can save things as R formats using `save()`. Just list multiple object names to save in the same .RData file. 

Fake dataset for manipulating.
Plots with 3 treatments with different time points and responses.

```{r getData, results='markdown', eval=TRUE}
load(file='../data/manipulationDatasets.RData')
dat.1 %>% head
```

`str()` used on any object. Tells you what the data are considered as. Is it what you expect? Could have a numeric column that is character because of a stray letter.

```{r checking data}
str(dat.1)

dat.1 %>% str()
```

Dense summary:

```{r glimpse}
glimpse(dat.1)
```

# Tidyverse

Collection of packages designed to work together.

Has a grammar.

## Dataframes and tibbles

Most things should work with both but not always...

```{r print as tibble}
dat.1 %>% as_tibble()
# SAME AS
dat.1 %>% as_tibble() %>% print
```

**Tibbles:**

* Print to fit on the consol 'page.'
* Rounds numbers for display, actual data has not been changed.
* Can put anything you like in a cell (instructions for a plot, a tibble) vs 1 number/factor in a dataframe.
  * For tibble with 2 factors - can put instructions for a graph in a cell. Pack a lot of information and don't need to use loops.
  * R is an interpretive (vs compiled) language where looping is slow.

# Piping

Write little programs that do one function - filter, sort, etc. - and then string them together using pipes.

Can use this for any function where a dataframe is the first argument.

```{r, results='markup'}
head(dat.1)
#OR
dat.1 %>% head()
#OR
dat.1 %>% head # with no args can leave off brackets - lintr will probably yell though
```

```{r storing piped outputs}
dat.1.trunc <- dat.1 %>% head()
# OR
dat.1 %>% head() -> dat.1.trunc
# more accessible in that it follows the logical order
```

Sorting data using arrange()
================

Does not reorder levels of a factor.

```{r sort by Resp1}
dat.1 %>% arrange(Resp1) # ascending order

# descending order
dat.1 %>% arrange(-Resp1) %>% head
dat.1 %>% arrange(desc(Resp1)) %>% 
  head %>% knitr::kable() # will come out as a nice neat table in html, no scroll bar so just used head
```

Sort by multiple columns:

```{r sort more columns}
dat.1 %>%  arrange(Dose, Resp1)
```

Sort by the sum of Resp1 and Resp2. Don't need to be existing columns - can create a new column from existing to sort by.

```{r sort by operation}
dat.1 %>% arrange(Resp1 + Resp2)
```

Sort by treatment then time.

```{r sort treatment, time}
head(dat.1)
dat.1 %>% arrange(Treatment, Time)
```

```{r Treatment then mean of Resp1, Resp2}
dat.1 %>% arrange(Treatment, mean(c(Resp1, Resp2))) # note vector to mean Resp1 and Resp2 columns
```

Adding columns - mutate()
===========================

`mutate()` is working row by row. Mutated dataframe not saved here but would probably want to.

```{r mutate Sum column}
dat.1 %>% mutate(Sum = Resp1 + Resp2)
```

Data transformation of columns.

```{r log a column}
dat.1 %>% mutate(logResp1 = log(Resp1)) # log() is natural log
```

# Centering of data

```{r centering}
dat.1 %>% mutate(MeanResp1 = mean(Resp1), # is a constant, summary function operates on whole column
                 cResp1 = Resp1 - MeanResp1) # 2nd bit uses column just created
# OR if just want the centered variable..
dat.1 %>% mutate(cResp1 = Resp1 - mean(Resp1)) %>% 
  head()
```

`mutate()` must give you as many rows as you started with.

Changing vector types (classes).

```{r Time to factor}
dat.1 %>% mutate(Time = factor(Time)) %>% as_tibble
```

Change factor to more descriptive factor labels. 

```{r changing factor labels}
dat.1 %>% mutate(Dose = fct_recode(Dose, High = 'H', Medium = 'M')) %>% 
  as_tibble
```

Pull out a single column as a vector with `pull()`.

```{r pull}
dat.1 %>% pull(Dose) # levels in alphabetical order

dat.1 %>% 
  mutate(dose = fct_relevel(Dose, c('L', 'M', 'H'))) %>% # relevel factors before pull()
  as_tibble() %>% 
  pull(Dose)
```

# Lead and lags

Useful to correlate response to last week or in future. Correlate to previous conditions.

```{r lead and lag}
dat.1 %>% mutate(leadResp2 = lead(Resp2), # shift up one
                 lagResp2 = lag(Resp2)) # shift down one
```

# Ranking 

```{r ranking}
dat.1 %>% mutate(rankTime = min_rank(Time), # ties.method = 'min'
                 denseRankTime = dense_rank(Time)) # like min_rank but no gaps between ranks
```

Rank orders

```{r rank orders}
dat.1 %>% mutate(rowresp1 = row_number(Resp1), # ties.method = 'first'
                 rowTime = row_number(Time),
                  rankTime = min_rank(Time))
```

Rank of bins:

```{r rank bins}
dat.1 %>% mutate(ntile(Resp1, 4)) # rough rank, breaks input vector into n buckets
```


# Window functions

## Logical bins: Resp1 between 20 and 40.

```{r Resp1 between 20 and 40}
dat.1 %>% mutate(between(Resp1, 20, 40)) # binary 0, 1 as T/F
```

## Categorical bins:

`ifelse()` condition when TRUE and condition when FALSE - nested `ifelse()` can be harder to follow.

`case_when()` avoids nesting, easier to follow, and neater.

```{r case when}
dat.1 %>% mutate(fResp1 = ifelse(Resp1 < 30, 'Low',
                          ifelse(between(Resp1, 31, 50), 'Medium', 'High')))
# OR
dat.1 %>% mutate(fResp1 = case_when(Resp1 < 31 ~ 'Low',
                          between(Resp1, 31, 50) ~ 'Medium',
                          Resp1 > 50 ~ 'High'))
```

```{r categories with cut}
dat.1 %>% mutate(fResp1 = cut(Resp1, breaks = c(0, 31, 50, 200), # very low and very high bounds, can use -Inf/Inf
                              labels = c("Low", "Medium", "High")))
```

Bin Time into Start (1 and 2) and end (3 and 4)

```{r bin time}
dat.1 %>% head()

dat.1 %>% mutate(SEtime = case_when(Time < 3 ~ 'Start',
                                    Time > 2 ~ 'End'))
# OR
dat.1 %>% mutate(Period = cut(Time, breaks = 2, labels = c('Start', 'End'))) # bit lazy
# OR
dat.1 %>% mutate(Period = cut(Time, breaks = c(0, 2.5, 4.5), labels = c('Start', 'End'))) # more breaks
```

Summarising (aggregating) data
=================================

Summarize data ends up as one row.

```{r summarize mean, variance, N}
dat.1 %>% summarize(MeanResp1 = mean(Resp1),
                VarResp1 = var(Resp1),
                N = n()) # only works inside tidyverse functions
```

Don't say anything about other columns (Treatment, Plot, Dose, Time) and are not included in aggregated output.

Can write own functions to summarize by.

```{r create SE function and summarize}
SE <- function(x) sd(x) / sqrt(length(x))
SE(1:5) # test function
SE(c(1,2,3,4,5,6,7,4,2,4,56,87,3,13,3))

dat.1 %>% summarize(MeanResp1 = mean(Resp1),
                    VarResp1 = var(Resp1),
                    SEM = SE(Resp1))
```

#across() versions of summarize()

```{r summarize mean using across}
dat.1 %>%  summarize(across(c(Resp1, Resp2),
                            mean))
```

```{r multiple functions}
dat.1 %>%  summarize(across(c(Resp1, Resp2),
                            list(mean, var))) # column names not useful

dat.1 %>%  summarize(across(c(Resp1, Resp2),
                            list(Mean = mean,
                                 Var = var))) # define column names
```

Can use `across()` by data types:

```{r using data types}
dat.1 %>% summarize(across(where(is.numeric), 
                                 list(Mean = mean,
                                      Var = var)))
```

Can treat summarize different data types simultaneously.

```{r is.numeric and is.factor}
dat.1 %>% summarize(across(where(is.numeric), mean),
                    across(where(is.factor), length))
```

Can pre-define variables of interest for `summarize()` and use `all_of()`.

```{r predefined variables}
Var <- c('Resp1', 'Resp2')
dat.1 %>% summarize(across(all_of(Var),
                           list(Mean = mean,
                                Var = var)))
```

`count()` examples.

```{r count}
dat.1 %>% count(Dose)
dat.1 %>% count(Dose, between(Resp1, 30, 50))
```

Grouping (=aggregating)
=========================

Summarize based on a variable(s).

**Critical** to remember to `ungroup()`. Anything do after will be grouped. 

```{r group_by Treatment and Plot}
dat.1 %>%  group_by(Treatment, Plot) %>% 
  summarize(Mean = mean(Resp1)) %>% 
  ungroup()
```

```{r summarize dat.1}
dat.1 %>% 
  group_by(Treatment, Plot) %>% 
  summarise(Mean = mean(Resp1),
              Var = var(Resp1),
              N = n(),
              First = first(Resp1))
```

# Reminder: mutate vs summarize

```{r mutate v summarize}
dat.1 %>%  group_by(Treatment, Plot) %>% 
  mutate(Mean = mean(Resp1))

dat.1 %>% group_by(Treatment, Plot) %>% 
  summarize(Mean = mean(Resp1))
```

# Tikus data

For each year (time), find the mean abundance of pocillopora damicornis.

```{r summarize tikus}
head(tikus)

tikus %>% 
  group_by(time) %>% 
  summarize(Mean = mean(`Pocillopora damicornis`))

str(tikus)
# Does not work - can't use across with group_by?
# tikus %>%
#   as_tibble() %>%
#   group_by(time) %>%
#   summarize(across(`Pocillopora damicornis`),
#             list(Mean = mean),
#             .groups = 'keep')

iris %>%
  group_by(Species) %>%
  summarise(across(starts_with("Sepal"), list(mean = mean, sd = sd)))
```

Subset columns
=================

`select()` columns.

```{r select}
dat.1 %>% select(Treatment, Plot, Dose, Time, Resp1)
```

Can also change the column names.

```{r select name change}
dat.1 %>% select(Treatment, Plot, Dose, Time, Abundance=Resp1)
```

```{r select all but...}
dat.1 %>% select(-Resp2)
```

# Helper functions

* `contains()` - every column that contains an 'a'
* `ends_with()`
* `starts_with()`
* `matches()` - matches a regular expression
* `everything()`
* `across()`

Columns containing an R. Not case sensitive.

```{r contains}
dat.1 %>% select(contains('r'))
```

```{r starts with}
dat.1 %>% select(starts_with('r'))

dat.1 %>% select(ends_with('e'))
```

```{r everything example}
dat.1 %>% select(Resp1, everything())
```

```{r using colon to select}
dat.1 %>%  select(Treatment:Time)
```

Murray is not a fan because it relies on the order of the columns.

With nasa data, select out lat, long, and all columns that have cloud in them.

```{r nasa example}
head(nasa)
nasa %>% 
  select(lat, long, contains('cloud'))
# OR
head(nasa)
nasa %>% 
  select(lat, long, starts_with('cloud')) %>% 
  head()
# OR
nasa %>% 
  select(lat, long, matches('cloud.*')) %>% 
  head()
```

From tikus, select rep, time, and only species that don't contain pora.

```{r tikus select}
tikus %>% 
  select(rep, time, -contains('pora'))
# OR
tikus %>% 
  select(rep, time, everything(), -contains('pora'))
```

## Regular expressions (regex)

https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf

```{r match with regex}
dat.1 %>%  select(matches("^.{4}$"))
```

# Rename

Only want to rename a few columns and keep everything else.

```{r rename}
dat.1 %>% rename(Exposure = Treatment,
                 Richness = Resp1)
```

Filtering
=============

Pick rows using logical conditions.

```{r filtering for Dose H}
dat.1 %>% filter(Dose == 'H')
```

!= is does not equal
>, <, <=, >= only on numeric

```{r multiple conditions}
dat.1 %>% filter(Dose == 'H' | Dose == 'M') %>%  # H OR M
  head()
# OR
dat.1 %>% filter(Dose %in% c('H', 'M')) %>% 
  head()
```

```{r multiple conditions different columns}
dat.1 %>%  filter(Dose == 'H' & Resp1 < 25) # both conditions must be met

dat.1 %>% filter(Dose == 'H' | Resp1 < 25) # either needs to be satisfied
```

Can nest filters.

Using nasa, filter to the largest ozone values for the second month of the last year.

```{r levels remain when filtering}
glimpse(nasa)
max(nasa$year)

nasa %>% 
  filter(year == max(year) & month == 2) %>% 
  arrange(-ozone) %>% 
  head(1)
nasa %>% filter(year == max(year) & month == 2) %>% 
  arrange(-ozone) %>% slice(1:5)
# OR
nasa %>% 
  filter(year == max(year) & month == 2) %>% 
  top_n(5, ozone)
```

# Effects of filtering

Filtering factors retains the metadata/levels of the original data.

```{r filtering and levels}
levels(dat.1$Dose)

dat.3 <- dat.1 %>% filter(Plot == 'P1')
levels(dat.1$Plot) # 4 levels even though filtered for 1 plot
str(dat.3$Plot)

dat.3 %>%  pull(Plot) # still see 'ghost' levels

dat.3 <- dat.3 %>% droplevels()
dat.3 %>%  pull(Plot) # only P1 level
```


Reshaping data
=================

Wide data is easier to read for humans and more space efficient.

## Pivot longer

```{r pivot longer}
data.w %>% pivot_longer(Time.0:Time.2, 
                        names_to = 'Time', # makes up if not supplied
                        values_to = 'Count')
# OR
data.w %>% pivot_longer(c(-Between, -Plot), 
                        names_to = 'Time',
                        values_to = 'Count')
# OR
data.w %>% pivot_longer(starts_with('Time'), 
                        names_to = 'Time',
                        values_to = 'Count',
                        names_prefix = 'Time.')
```

## Pivot wider

```{r head data}
data %>% head(2)
```

Data has two response variables (Resp1, Resp2). Want to turn longish data wider into columns with B1 and B2. Only interested in Resp1 here.

```{r pivot wider without Resp2}
data %>% select(-Resp2) %>% 
  pivot_wider(names_from = Within, values_from = c(Resp1))
```

```{r pivot wider with both Resp1, Resp2}
data %>% 
  pivot_wider(names_from = Within, values_from = c(Resp1, Resp2))
```

Combining data
=================

Combine ecological with environmental data, for example.

Three ways to join data. Terminology comes from databases.

1. `left_join()` - keeps everything on the left dataframe and as much of right dataframe that matches. Also a `right_join()` for piping convenience.
2. `inner_join()` - only matches what is common to both.
3. `full_join()` - keeps everything from each dataframe. Safest don't lose anything.

Good to get rid of superfluous columns before joining. Good practice to rename 'join' column to match. Can use select:

`data %>% left_join(other.data %>%  select(X = A, Var))`

Also an `anti_join()` to see what does not match.

```{r look at data to join}
data.bio %>% head()
data.chem %>% head()
```

```{r join bio and chem data}
data.bio %>% inner_join(data.chem)

data.bio %>% anti_join(data.chem) # shows physio chem data Subplot is missing S7

data.bio %>% full_join(data.chem)

data.bio %>% left_join(data.chem) # no S3 row, no chem data for S7
```

Can change order of rows - pipe to arrange.

> Merge is not as efficient and does not work as well with tidyverse ecosystem.

> aresenal package to compare dataframes 'compare df'

Applied examples
===================
