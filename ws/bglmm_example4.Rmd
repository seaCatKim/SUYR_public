---
title: "Bayesian GLMM example 4"
author: "Murray Logan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: show
    collapse: no
    df_print: paged
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: textmate
    theme: spacelab
    toc: yes
    toc_float: yes
    css: ../resources/style.css
  pdf_document:
    df_print: default
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: tango
    latex_engine: xelatex
    number_sections: yes
    toc_depth: 2
  word_document:
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: tango
    toc: yes
    toc_depth: 2
output_dir: "docs"
documentclass: article
fontsize: 12pt
mainfont: Arial
mathfont: LiberationMono
monofont: DejaVu Sans Mono
classoption: a4paper
bibliography: ../resources/references.bib
---

```{r setup, include=FALSE, warnings=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preparations

Load the necessary libraries

```{r libraries, results='markdown', eval=TRUE, message=FALSE, warning=FALSE}
library(car)       #for regression diagnostics
library(broom)     #for tidy output
library(ggfortify) #for model diagnostics
library(sjPlot)    #for outputs
library(knitr)     #for kable
library(effects)   #for partial effects plots
library(emmeans)   #for estimating marginal means
library(MASS)      #for glm.nb
library(MuMIn)     #for AICc
library(tidyverse) #for data wrangling
library(brms)
library(loo) # should be dependency of another package...
library(DHARMa)
library(tidybayes)
```

# Scenario

Someone did something for some reason.....

# Read in the data

```{r readData, results='markdown', eval=TRUE}
mckeon = read_csv('../data/mckeon.csv', trim_ws=TRUE)
glimpse(mckeon)
```

Block - tank number - needs to be a factor
Predation - 0/1, yes/no
Symbiont - treatment, none, one, both - needs to be factor, reorder 

```{r factorize}
mckeon <- mckeon %>% 
  mutate(BLOCK = factor(BLOCK),
         SYMBIONT = factor(SYMBIONT, levels = c('none', 'crabs', 'shrimp', 'both'
                                                )))

levels(mckeon$SYMBIONT)
```


# Exploratory data analysis

Model formula:
$$
y_i \sim{} \mathcal{N}(n, p_i)\\
ln\left(\frac{p_i}{1-p_1}\right) =\boldsymbol{\beta} \bf{X_i} + \boldsymbol{\gamma} \bf{Z_i}
$$

where $\boldsymbol{\beta}$ and $\boldsymbol{\gamma}$ are vectors of the fixed and random effects parameters respectively and $\bf{X}$ is the model matrix representing the overall intercept and effects of symbionts on the probability of the colony experiencing predation.
$\bf{Z}$ represents a cell means model matrix for the random intercepts associated with individual coral colonies.

$\beta_0$ average predation in none group
3 other $\beta$s 
$\gamma$ difference back to the intercept

# Informative priors model

Try out very informative priors:

Very precise intercept - very sure that my intercept is 0.5 (middle of 0-1, 0 on logit scale)

We think treatments (crabs, shrimp, both) have a positive impact at the same rate (all the same rate, one prior for all). With very low variance.

```{r tight priors}
priors1 <- prior(normal(0, 0.001), class = 'Intercept') + 
  prior(normal(3, 0.001), class = 'b') +
  prior(cauchy(0, .1), class = 'sd')
```

```{r intercept formula}
mckeon.form <- bf(PREDATION | trials(1) ~ SYMBIONT + (1|BLOCK),
                  family = binomial(link = 'logit'))
```

```{r fit intercept model}
mckeon.brm2b <- brm(mckeon.form,
                   data = mckeon,
                   prior = priors1,
                   sample_prior = 'only',
                   iter = 5000,
                   warmup = 1000,
                   chains = 3, 
                   thin = 5)
```

```{r tight prior plot}
mckeon.brm2b %>% conditional_effects() %>% plot()
```

Priors for $\beta$s alwasy normal - central limit theorem.

$\beta_0$ log of 0.5 - 0

Cauchy is a type of t distribution with 1 degree of freedom - a flat normal distribution.

No sigma - not in distribution.

Everything on logit scale so small numbers are quite wide distributions.

Safer to go wider for priors up to a point - get stuck.

$$
\beta_0 \sim \mathcal{N}(0, 2\\
\beta_i \sim \mathcal{N}(0, 5)\\
\sigma^2 \sim \mathcal{Cauchy}(0, 2)\\
$$

```{r set priors}
priors <- prior(normal(0, 2), class = 'Intercept') +
  prior(normal(0, 5), class = 'b') +
  prior(cauchy(0, 1), class = 'sd')
```

# Fit model {.tabset .tabset-faded}

## Random intercepts model

Regular binomial is number of successes to number of trials - `PREDATION | trials(1)`. Special case (Bernoulli), one trial at a time so `trails(1)`. If was always out of ten could put the variable (total whatever variable name) or 10 there `trials(Total)` or `trials(10)`.

```{r fit intercept model, cache = TRUE}
mckeon.brm2 <- brm(mckeon.form,
                   data = mckeon,
                   prior = priors,
                   sample_prior = 'only',
                   iter = 5000,
                   warmup = 1000,
                   chains = 3, 
                   thin = 5)
```

Check priors. Can only predict between 0-1 so priors allow for anything.

```{r check priors}
mckeon.brm2 %>% conditional_effects() %>% plot()
```

## Random slopes and intercept

```{r intercept and slope formula}
mckeon.form <- bf(PREDATION | trials(1) ~ SYMBIONT + (SYMBIONT|BLOCK),
                  family = binomial(link = 'logit')
                )
```

For reproducibility would `set.seed()` directly before the model to get the same results. `brm()` can set in the model.

```{r fit intercept slope model}
mckeon.brm3 <- brm(mckeon.form,
                   data = mckeon,
                   prior = priors,
                   sample_prior = 'yes',
                   iter = 5000,
                   warmup = 1000,
                   chains = 3, 
                   thin = 5,
                   control = list(adapt_delta = 0.9))
```

Taking a while... Efficiency is probably low.
Despite using `adapt_delta` still has divergent transitions. Would make gamma sigma prior more narrow (not betas).

```{r notes}
plogis(-2.5)
plogis(-20000.5)

# trying to not back transform and keep on link scale but not working
mckeon.brm3 %>% conditional_effects(transform = I, method = 'posterior_predict')

# murray's preferred
mckeon.brm3 %>% ggemmeans(~ SYMBIONT) %>% plot()
mckeon.brm3 %>% ggemmeans(~ SYMBIONT, exponentiate = FALSE) %>% plot()
mckeon.brm3 %>% ggpredict(~ SYMBIONT, back.transform = FALSE) %>% plot()

# could calc yourself then plot
mckeon.brm3 %>% emmeans(~SYMBIONT, type = 'link')  # link scale
mckeon.brm2 %>% emmeans(~SYMBIONT, type = 'link') # link scale
```

```{r conditional with random slopes}
mckeon.brm3 %>% conditional_effects() %>% plot()
```

## Compare models

Random slopes model is better.

```{r loos}
(l.1 <- mckeon.brm2 %>% loo())
(l.2 <- mckeon.brm3 %>% loo())
loo_compare(l.1 = l.1, l.2)
```

intercept at none
difference crab, shrimp, both compared to none
variance of crabs, shrimp, and both

```{r get variables}
mckeon.brm3 %>% get_variables()
```

Could be wider. Would not want it to get tighter than that. would indicate would not priors more narrow than this.

```{r plot shrimp}
mckeon.brm3 %>% hypothesis('SYMBIONTshrimp = 0', class = 'b') %>% plot()
```

```{r plot crab}
mckeon.brm3 %>% hypothesis('SYMBIONTcrabs = 0', class = 'b') %>% plot()
```
# MCMC validation {.tabset .tabset-faded}

## Trace plots

BLOCK_SYMBIONTcrabs problematic. BLOCK_SYMBIONTs plots are centered around 0, but crab one has some values that are way out there. 

Again tells us that the Cauchy (0, 2) is too wide - unlikely that the variability would be 5000. Does not make logical sense. Tightening cauchy should address, run faster, less divergent transitions etc. something like Cauchy(0, 1).

```{r tract}
mckeon.brm3$fit %>% stan_trace()
```

## Autocorrlation

Would expect step length might be too big. Some may be 0.2. 

Could up the thinning, but narrowing the Cauchy might also address without changing the thinning.

```{r ac}
mckeon.brm3$fit %>% stan_ac()
```

## Rhat

Not too bad - chains were equally bad/good for all.

```{r rhat}
mckeon.brm3$fit %>% stan_rhat()
```

## Efficiency

Low efficiency - throwing out a lot of samples.
```{r ess}
mckeon.brm3$fit %>% stan_ess()
```

All the MCMC validation is about the variance - Cauchy - for random effects. Know from above that Bi is almost too narrow.

Should narrow Cauch and rerun.

## Spaghetti

No useful for binomial.

```{r}
mckeon.brm3 %>% pp_check(type = 'dens_overlay', nsamples = 100)
```

# Model validation

DHARMa residuals.

Despite all the issues above, the model is a good fit. Impact was minimal.

```{r DHARMa}
preds <- mckeon.brm3 %>% posterior_predict(nmsaples = 250, summary = FALSE)
mckeon.resids <- createDHARMa(simulatedResponse = t(preds),
                               observedResponse = mckeon$PREDATION,
                               fittedPredictedResponse = apply(preds, 2, median),
                               integerResponse = FALSE)
plot(mckeon.resids, quantreg = FALSE)
```

# Conditional plots

Expectations:

- none group high probability of predated on
- less in crab, shrimps, both, but substantial amount of variability

```{r conditional plots}
mckeon.brm3 %>% 
  conditional_effects() %>% 
  plot(points = TRUE)
```

# Model investigation

Population level effects: logit

- Intercept 3 `r plogis(3.1)` 
    - probability of predation with no symbionts is about 96%
    - odds ratio `r exp(3.1)` x more likely to be predated on than not
- Predation probability declined by `r exp(-1.5)`
    - probability of `r plogis(3.1 - 1.5)` predation
    - odds of being predated by the crab is 4x `r .8 / (1-.8)`

```{r summary}
mckeon.brm3 %>% summary()
```

# Additional analyses {.tabset .tabset-faded}

Which scale - link-scale, odds, abs change in probability

Data are on 0-1 scale, use logit transform back to 0-1 scale.

Binomial - logit scale 

link - logit - log odds ratio - scale $\log{\frac{p_i}{1-p_1}}$
exp to:
odds ratio - fold-scale - $\frac{p_i}{1-p_1}$
probability - p

  - for when talking about a mean of something
  
`plogis()` goes straight from link to probability
  
Difference cannot turn into p.

## Tukey's pairwise

Link scale

could exponentiate to get it into odds ratio.

```{r link emmeans}
mckeon.brm3 %>%  emmeans(~SYMBIONT, type = 'link') %>% pairs()

exp(1.86) # odds changing 6.4
1/exp(1.86) # makes sense
plogis(1.86) # goes from link to probability does not make sense
```

Want odds ratio scale:

- Odds of predation in none group is 6x higher than crab group.
    - 16x higher than shrimp group
    - 51x higher than both group
- Odds 2x higher in crabs than shrimp
etc.

```{r odds emeans}
mckeon.brm3 %>% 
  emmeans(~SYMBIONT, type = 'response') %>% # odd ratio
  pairs()
```

```{r regrid odds scale}
mckeon.brm3 %>% 
  emmeans(~SYMBIONT) %>% # odd ratio
  pairs() %>% 
  regrid() # regrid after it's done the pairs, does what's sensible though, here keeps it on odds ratio because difference in probability does not make sense
```

Probability of decline from none - shrimp is 0.143 probability. Not that useful.

```{r probability}
mckeon.brm3 %>% 
  emmeans(~SYMBIONT, type = 'link') %>% # odd ratio
  regrid() %>%  # transform to probability
  pairs() # comparing those probabilities
```

## Calculate probabilities

```{r gather draws}
mckeon.brm3 %>% 
  emmeans(~SYMBIONT, type = 'link') %>% 
  pairs %>% 
  regrid %>% 
  gather_emmeans_draws() -> mckeon.em
head(mckeon.em)
```

Any evidence that crabs give us some protection. No evidence p = 0.72. Probability that predation is higher in the none group is 70% - want > 80%

Some evidence for shrimp and both. No reference to how much protection (size of effect). Just evidence of an effect.

No evidence difference for crab and shrimp. Both seems better than just crabs.

```{r p-value}
mckeon.em %>% summarize(P = sum(.value > 1)/n()) # fold scale is 1, 1x is the same
```

## Planned comparisons

Novel comparisons:

1. Crab or shrimp.
2. Either crab or shrimp compared to both
2. No symbionts to average of 3 symbiont groups.

```{r contrast matrix}
cmat <- cbind(crab_v_shrimp = c(0,1,-1,0),
              one_v_both = c(0, 1/2, 1/2, -1),
              symbiont = c(1, -1/3, -1/3, -1/3))
cmat
```

Odds of predation on crabs is 2.5x higher than shrimp.

Odds of predation on one (ave of crabs of shrimp) is 5.8x higher than both.

Any symbiont has 14x more protection than none.

```{r contrasts}
mckeon.em <- mckeon.brm3 %>% 
  emmeans(~SYMBIONT, type = 'link') %>% 
  contrast(method = list(cmat)) %>% 
  gather_emmeans_draws() %>% # will always use the link
  mutate(Fit = exp(.value)) # odds ratio, could put regrid but mutate keeps .value and Fit
mckeon.em %>% median_hdci(Fit)
```

Some evidence that both symbionts offers more protection than one.

Strong evidence any any symbiont offers more protection than no symbiont.

No evidence at all whether it's a crab or a shrimp.

```{r sym probabilities}
mckeon.em %>% summarize(P = sum(Fit > 1)/ n())
```


# Rstan code

```{r fitModel, results='markdown', eval=FALSE, hidden=TRUE}
mckeon = mckeon %>% mutate(BLOCK=factor(BLOCK),
   SYMBIONT=factor(SYMBIONT, levels=c('none','crabs','shrimp','both')))

ggplot(mckeon, aes(y=PREDATION, x=SYMBIONT)) +
    geom_point(position=position_jitter(width=0.2, height=0))+
    facet_wrap(~BLOCK)

mckeon.rstan = stan_glmer(PREDATION ~ SYMBIONT + (1|BLOCK),
                          data=mckeon, family=binomial(link='logit'),
                          iter=5000, warmup=2000, chains=3, thin=5, refresh=0,
                          cores=3)
mckeon.rstan %>% get_variables()
plot(mckeon.rstan,  'mcmc_trace', regex_pars='^.Intercept|SYMBIONT|[sS]igma')
plot(mckeon.rstan,  'mcmc_acf_bar', regex_pars='^.Intercept|SYMBIONT|[sS]igma')
plot(mckeon.rstan,  'mcmc_rhat_hist', regex_pars='^.Intercept|SYMBIONT|[sS]igma')
plot(mckeon.rstan,  'mcmc_neff_hist', regex_pars='^.Intercept|SYMBIONT|[sS]igma')


preds <- posterior_predict(mckeon.rstan,  nsamples=250,  summary=FALSE)
mckeon.resids <- createDHARMa(simulatedResponse = t(preds),
                            observedResponse = mckeon$PREDATION,
                            fittedPredictedResponse = apply(preds, 2, median))
plot(mckeon.resids)

mckeon.rstan1 = stan_glmer(PREDATION ~ SYMBIONT + (SYMBIONT|BLOCK),
                           data=mckeon, family=binomial(link='logit'),
                           iter=5000, warmup=2000, chains=3, thin=5, refresh=0,
                          cores=3)

mckeon.rstan1 %>% get_variables()
plot(mckeon.rstan1,  'mcmc_trace', regex_pars='^.Intercept|^SYMBIONT|[sS]igma')  
plot(mckeon.rstan1,  'mcmc_acf_bar', regex_pars='^.Intercept|^SYMBIONT|[sS]igma')
plot(mckeon.rstan1,  'mcmc_rhat_hist', regex_pars='^.Intercept|^SYMBIONT|[sS]igma')
plot(mckeon.rstan1,  'mcmc_neff_hist', regex_pars='^.Intercept|^SYMBIONT|[sS]igma')


preds <- posterior_predict(mckeon.rstan1,  nsamples=250,  summary=FALSE)
mckeon.resids <- createDHARMa(simulatedResponse = t(preds),
                            observedResponse = mckeon$PREDATION,
                            fittedPredictedResponse = apply(preds, 2, median))
plot(mckeon.resids)

#prior_summary(mckeon.rstan1)
#posterior_vs_prior(mckeon.rstan1, color_by='vs', group_by=TRUE,
#                   facet_args=list(scales='free_y'))

loo(mckeon.rstan)
loo(mckeon.rstan1)

#as.matrix(mckeon.rstan1) %>% colnames
#posterior_vs_prior(mckeon.rstan1, color_by='vs', group_by=TRUE,
#                   regex_pars=c('^(Intercept)','^SYMBIONT','^[sS]igma'), 
#                   facet_args=list(scales='free_y'))

## mckeon.rstan1 = stan_glmer(PREDATION ~ SYMBIONT + (SYMBIONT|BLOCK),
##                           data=mckeon, family=binomial(link='logit'),
##                           iter=4000, warmup=1000, chains=3, thin=5, refresh=0,
##                           cores=3,
##                           prior_intercept = normal(0,10),
##                           prior=normal(0,2.5),
##                           prior_covariance = decov(1,1,1,4))
## posterior_vs_prior(mckeon.rstan1, color_by='vs', group_by=TRUE, regex_pars=c('^(Intercept)','^SYMBIONT','^[sS]igma'), 
##                    facet_args=list(scales='free_y'))
ggpredict(mckeon.rstan1) %>% plot
summary(mckeon.rstan1)

mckeon.rstan1 %>% get_variables()
nms=colnames(as.matrix(mckeon.rstan1))
wch = grep('^.Intercept|^SYMBIONT',nms)
#posterior_vs_prior(mckeon.rstan1, color_by='vs', group_by=TRUE,
#                   facet_args=list(scales='free_y'), pars=nms[wch])



tidyMCMC(mckeon.rstan1$stanfit,conf.int=TRUE, conf.method='HPDinterval',
         rhat=TRUE, ess=TRUE,  pars=nms[wch])

emmeans(mckeon.rstan1, pairwise~SYMBIONT, type='response')
mckeon.em = emmeans(mckeon.rstan1, pairwise~SYMBIONT, type='link')$contrasts %>%
      gather_emmeans_draws() %>%
      mutate(PEff=exp(.value))
mckeon.em %>% head
mckeon.em %>%
  group_by(contrast) %>%
  dplyr::select(contrast, PEff) %>%
  median_hdci
mckeon.em %>%
  group_by(contrast) %>%
  summarize(Prob=sum(PEff>1)/n())

cmat=cbind(
    crab_vs_shrimp=c(0,1,-1,0),
    one_vs_both=c(0,-1/2,-1/2,1),
    symbiont=c(1, -1/3, -1/3,-1/3)
)
mckeon.em = emmeans(mckeon.rstan1, ~SYMBIONT, contr=list(cmat), type='link')$contrast %>%
                                                                 gather_emmeans_draws() %>%
                                                                 mutate(Fit=exp(.value)) 
mckeon.em %>%
  group_by(contrast) %>%
  median_hdci(Fit)

mckeon.em %>%
  group_by(contrast) %>%
  summarize(sum(Fit>1)/n())                                                                      

newdata = emmeans(mckeon.rstan1, ~SYMBIONT, type='response') %>% as.data.frame
head(newdata)
ggplot(newdata, aes(y=prob, x=SYMBIONT)) +
    geom_pointrange(aes(ymin=lower.HPD, ymax=upper.HPD))

```

```{r fitModel.brms, results='markdown', eval=FALSE, hidden=TRUE}
mckeon = mckeon %>% mutate(BLOCK=factor(BLOCK),
   SYMBIONT=factor(SYMBIONT, levels=c('none','crabs','shrimp','both')))

ggplot(mckeon, aes(y=PREDATION, x=SYMBIONT)) +
    geom_point(position=position_jitter(width=0.2, height=0))+
    facet_wrap(~BLOCK)

ggplot(mckeon, aes(y=PREDATION, x=SYMBIONT)) +
    geom_point()+
    facet_wrap(~BLOCK)
mckeon.form <- bf(PREDATION | trials(1) ~ SYMBIONT + (1|BLOCK),
                  family=binomial(link='logit'))
mckeon.brms <- brm(mckeon.form,
                   data=mckeon,
                   iter=5000, warmup=2000, chains=3, thin=5, refresh=0,
                   cores=3)
mcmc_plot(mckeon.brms,  type='trace')

mckeon.brms %>% get_variables()
mcmc_plot(mckeon.brms,  type='trace')
, regex_pars='^.Intercept|SYMBIONT|sd')
mcmc_plot(mckeon.brms,  type='acf_bar')
, regex_pars='^.Intercept|SYMBIONT|sd')
mcmc_plot(mckeon.brms,  type='rhat_hist')
, regex_pars='^.Intercept|SYMBIONT|sd')
mcmc_plot(mckeon.brms,  type='neff_hist')
, regex_pars='^.Intercept|SYMBIONT|sd')


preds <- posterior_predict(mckeon.brms,  nsamples=250,  summary=FALSE)
mckeon.resids <- createDHARMa(simulatedResponse = t(preds),
                            observedResponse = mckeon$PREDATION,
                            fittedPredictedResponse = apply(preds, 2, median),
                            integerResponse=TRUE)
plot(mckeon.resids)

mckeon.form <- bf(PREDATION | trials(1) ~ SYMBIONT + (SYMBIONT|BLOCK),  family=binomial(link='logit'))
mckeon.brms1 <- brm(mckeon.form,
                   data=mckeon,
                   iter=5000, warmup=2000, chains=3, thin=5, refresh=0,
                   cores=3)

mcmc_plot(mckeon.brms1,  type='trace')
mcmc_plot(mckeon.brms1,  type='trace', regex_pars='^.Intercept|SYMBIONT|sd')
mcmc_plot(mckeon.brms1,  type='acf_bar')
, regex_pars='^.Intercept|SYMBIONT|sd')
mcmc_plot(mckeon.brms1,  type='rhat_hist')
, regex_pars='^.Intercept|SYMBIONT|sd')
mcmc_plot(mckeon.brms1,  type='neff_hist')
, regex_pars='^.Intercept|SYMBIONT|sd')

preds <- posterior_predict(mckeon.brms1,  nsamples=250,  summary=FALSE)
mckeon.resids <- createDHARMa(simulatedResponse = t(preds),
                            observedResponse = mckeon$PREDATION,
                            fittedPredictedResponse = apply(preds, 2, median),
                            integerResponse = TRUE)
plot(mckeon.resids)

#prior_summary(mckeon.brms1)
#posterior_vs_prior(mckeon.brms1, color_by='vs', group_by=TRUE,
#                   facet_args=list(scales='free_y'))

loo(mckeon.brms)
loo(mckeon.brms1)

#as.matrix(mckeon.brms1) %>% colnames
#posterior_vs_prior(mckeon.brms1, color_by='vs', group_by=TRUE,
#                   regex_pars=c('^(Intercept)','^SYMBIONT','^[sS]igma'), 
#                   facet_args=list(scales='free_y'))

## mckeon.brms1 = stan_glmer(PREDATION ~ SYMBIONT + (SYMBIONT|BLOCK),
##                           data=mckeon, family=binomial(link='logit'),
##                           iter=4000, warmup=1000, chains=3, thin=5, refresh=0,
##                           cores=3,
##                           prior_intercept = normal(0,10),
##                           prior=normal(0,2.5),
##                           prior_covariance = decov(1,1,1,4))
## posterior_vs_prior(mckeon.brms1, color_by='vs', group_by=TRUE, regex_pars=c('^(Intercept)','^SYMBIONT','^[sS]igma'), 
##                    facet_args=list(scales='free_y'))
ggpredict(mckeon.brms1) %>% plot

mckeon.brms1 %>% get_variables()
nms=colnames(as.matrix(mckeon.brms1))
wch = grep('^b.Intercept|^b.SYMBIONT|^sd',nms)
#posterior_vs_prior(mckeon.brms1, color_by='vs', group_by=TRUE,
#                   facet_args=list(scales='free_y'), pars=nms[wch])



summary(mckeon.brms1)
tidyMCMC(mckeon.brms1$fit,  estimate.method = 'median',
         conf.int=TRUE,  conf.method = 'HPDinterval',
         rhat=TRUE, ess=TRUE)
tidyMCMC(mckeon.brms1$fit,conf.int=TRUE, conf.method='HPDinterval',
         rhat=TRUE, ess=TRUE,  pars=nms[wch])
tidyMCMC(mckeon.brms1$fit,conf.int=TRUE, conf.method='HPDinterval',
         rhat=TRUE, ess=TRUE)

emmeans(mckeon.brms1, pairwise~SYMBIONT, type='response')
mckeon.em = emmeans(mckeon.brms1, pairwise~SYMBIONT, type='link')$contrasts %>%
      gather_emmeans_draws() %>%
      mutate(PEff=exp(.value))#,
             #Prob = plogis(.value))
mckeon.em %>% head
mckeon.em %>%
  group_by(contrast) %>%
  dplyr::select(contrast, PEff) %>%
  median_hdi
mckeon.em %>%
  group_by(contrast) %>%
  summarize(Prob=sum(PEff>1)/n())

mckeon.em = emmeans(mckeon.brms1, ~SYMBIONT, type='link') %>%
      gather_emmeans_draws()
mckeon.em %>% mutate(P=plogis(.value)) %>% median_hdci(P)

mutate(PEff=exp(.value)))#,
             #Prob = plogis(.value))

cmat=cbind(
    crab_vs_shrimp=c(0,1,-1,0),
    one_vs_both=c(0,-1/2,-1/2,1),
    symbiont=c(1, -1/3, -1/3,-1/3)
)
mckeon.em = emmeans(mckeon.brms1, ~SYMBIONT, contr=list(cmat), type='link')$contrast %>%
                                                                 gather_emmeans_draws() %>%
                                                                 mutate(Fit=exp(.value)) 
mckeon.em %>%
  group_by(contrast) %>%
  median_hdi(Fit)

mckeon.em %>%
  group_by(contrast) %>%
  summarize(sum(Fit>1)/n())                                                                      

newdata = emmeans(mckeon.brms1, ~SYMBIONT, type='response') %>% as.data.frame
head(newdata)
ggplot(newdata, aes(y=prob, x=SYMBIONT)) +
    geom_pointrange(aes(ymin=lower.HPD, ymax=upper.HPD))

```

# References
 